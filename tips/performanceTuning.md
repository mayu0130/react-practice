# パフォーマンスチューニングとは？

**パフォーマンス**
Webにおけるパフォーマンスは、主にサイトの表示速度やユーザのアクションに対する反応の速さを指すことが多いです。

**チューニング**
パフォーマンスを良くすること、最適化することです。

## Reactにおけるパフォーマンスチューニングとは？

主にコンポーネントが再レンダーされるタイミングをなるべく少なくすることです。

## コンポーネントが再レンダーされるタイミング

**Propsの変更**
親コンポーネントから渡されるPropsが変更された場合、子コンポーネントが再レンダーされる。

**ステート(State)の変更**
コンポーネント内で管理されているステートが変更された場合、そのコンポーネントは再レンダーされます。これはsetStateによってステートが更新されると、再レンダーがトリガーされる仕様のためです。

**コンテキストの変更**
コンポーネントがuseContextを使用している場合、使用しているコンテキストの値が変更されると、そのコンポーネントは再レンダーされます。コンテキストプロバイダーが新しい値を提供すると、コンテキストの値を利用している全てのコンポーネントが再レンダーされます。

**親コンポーネントの再レンダー**
親コンポーネントが再レンダーされると、その子コンポーネントも再レンダーされる可能性があります。たとえプロパティやステートに変更がなくても、親が再レンダーされると、そのツリー全体レンダーされることがあります。

## 不要な再レンダーを防ぐパフォーマンスチューニング

**memo**
propsが変更されない限り、コンポーネントは再レンダーされません。
```
const MyComponent = memo(({title, description} :Props) => {
  //コンポーネントの内容
});
```

**useCallback**
関数を子コンポーネントに渡す場合、その関数が再生成されると子コンポーネントも再レンダーされます。useCallbackを使って関数をメモ化し、依存関係が変更されない限り同じ関数インスタンスを維持することで、不要な再レンダーを防ぎます。
```
const handleClick = useCallback (() => {
  //ハンドラの内容
}, [依存関係]);

const MyComponent = memo(({title, description, handleClick} : Props) => {
  //コンポーネント内容
});
```

**useMemo**
計算コストの高い計算結果やオブジェクト、配列などをメモ化することで依存関係されない限り再計算を防ぎます。これにより、不要な再レンダーが防げます。
```
const memoizedValue = useMemo(() => {
  return 思い計算;
}. [依存関係])
```
ただし、依存関係を正しく設定しないとバグの元になってなってしまうのが難しいところ
Propsと依存関係の比較は、内部的にはObject.js()を利用しています。

## パフォーマンスチューニングは必須なのか？

パフォーマンスチューニングは必要に応じて行うべきで、常に最優先するべきものではありません。明確なパフォーマンスが問題ない限り。過度な最適化を避け、コードのシンプルさと保守性を保つことが大切です。問題が発生した場合に適切に対処できるよう、React Dev Toolsなどの2つを使って定期的にパフォーマンスを監視し、必要なときに最適化するのかが良いアプローチです。